{"version":3,"file":"static/js/8930.4e24483b.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VCF from '@gmod/vcf'\nimport VcfFeature from '../VcfTabixAdapter/VcfFeature'\n\nconst readVcf = (f: string) => {\n  const header: string[] = []\n  const rest: string[] = []\n  f.split('\\n')\n    .map(f => f.trim())\n    .filter(f => !!f)\n    .forEach(line => {\n      if (line.startsWith('#')) {\n        header.push(line)\n      } else if (line) {\n        rest.push(line)\n      }\n    })\n  return { header: header.join('\\n'), lines: rest }\n}\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  protected vcfFeatures?: Promise<{\n    header: string\n    intervalTree: Record<string, IntervalTree>\n  }>\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.setup()\n    const parser = new VCF({ header: header })\n    return parser.getMetadata()\n  }\n\n  // converts lines into an interval tree\n  public async setupP() {\n    const pm = this.pluginManager\n    const buf = await openLocation(this.getConf('vcfLocation'), pm).readFile()\n\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n\n    const str = new TextDecoder().decode(buffer)\n    const { header, lines } = readVcf(str)\n\n    const intervalTree = lines\n      .map((line, id) => {\n        const [refName, startP, , ref, , , , info] = line.split('\\t')\n        const start = +startP - 1\n        const end = +(info.match(/END=(\\d+)/)?.[1].trim() || start + ref.length)\n        return { line, refName, start, end, id }\n      })\n      .reduce((acc, obj) => {\n        const key = obj.refName\n        if (!acc[key]) {\n          acc[key] = new IntervalTree()\n        }\n        acc[key].insert([obj.start, obj.end], obj)\n        return acc\n      }, {} as Record<string, IntervalTree>)\n\n    return { header, intervalTree }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch(e => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTree } = await this.setup()\n    return Object.keys(intervalTree)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { header, intervalTree } = await this.setup()\n        const parser = new VCF({ header: header })\n        intervalTree[refName]?.search([start, end]).forEach(f =>\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(f.line),\n              parser,\n              id: `${this.id}-${f.id}`,\n            }),\n          ),\n        )\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["readVcf","f","header","rest","split","map","trim","filter","forEach","line","startsWith","push","join","lines","isGzip","buf","VcfAdapter","vcfFeatures","this","setup","parser","VCF","getMetadata","pm","pluginManager","openLocation","getConf","readFile","unzip","buffer","length","Error","str","TextDecoder","decode","intervalTree","id","refName","startP","ref","start","end","match","reduce","acc","obj","key","IntervalTree","insert","setupP","catch","e","undefined","Object","keys","region","opts","ObservableCreate","observer","search","next","VcfFeature","variant","parseLine","complete","error","signal","BaseFeatureDataAdapter","capabilities"],"sourceRoot":""}