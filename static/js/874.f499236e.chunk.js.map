{"version":3,"file":"static/js/874.f499236e.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/MCScanAnchorsAdapter/MCScanAnchorsAdapter.ts","../../../plugins/comparative-adapters/src/util.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { doesIntersect2 } from '@jbrowse/core/util'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { readFile, parseBed } from '../util'\n\ninterface BareFeature {\n  strand: number\n  refName: string\n  start: number\n  end: number\n  score: number\n  name: string\n}\n\ntype Row = [BareFeature, BareFeature, number, number]\n\nexport default class MCScanAnchorsAdapter extends BaseFeatureDataAdapter {\n  private setupP?: Promise<{\n    assemblyNames: string[]\n    feats: Row[]\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  async setup(opts: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n  async setupPre(opts: BaseOptions) {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n\n    const pm = this.pluginManager\n    const bed1 = openLocation(this.getConf('bed1Location'), pm)\n    const bed2 = openLocation(this.getConf('bed2Location'), pm)\n    const mcscan = openLocation(this.getConf('mcscanAnchorsLocation'), pm)\n    const [bed1text, bed2text, mcscantext] = await Promise.all(\n      [bed1, bed2, mcscan].map(r => readFile(r, opts)),\n    )\n\n    const bed1Map = parseBed(bed1text)\n    const bed2Map = parseBed(bed2text)\n    const feats = mcscantext\n      .split('\\n')\n      .filter(f => !!f && f !== '###')\n      .map((line, index) => {\n        const [name1, name2, score] = line.split('\\t')\n        const r1 = bed1Map.get(name1)\n        const r2 = bed2Map.get(name2)\n        if (!r1 || !r2) {\n          throw new Error(`feature not found, ${name1} ${name2} ${r1} ${r2}`)\n        }\n        return [r1, r2, +score, index] as Row\n      })\n\n    return {\n      assemblyNames,\n      feats,\n    }\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures\n    // so is not really that important, and has to be true or else\n    // getFeatures is never called (BaseFeatureDataAdapter filters it out)\n    return true\n  }\n\n  async getRefNames() {\n    // we cannot determine this accurately\n    return []\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { assemblyNames, feats } = await this.setup(opts)\n\n      // The index of the assembly name in the region list corresponds to\n      // the adapter in the subadapters list\n      const index = assemblyNames.indexOf(region.assemblyName)\n      if (index !== -1) {\n        feats.forEach(f => {\n          const [r1, r2, score, rowNum] = f\n          const [f1, f2] = index === 1 ? [r2, r1] : [r1, r2]\n          if (\n            f1.refName === region.refName &&\n            doesIntersect2(region.start, region.end, f1.start, f1.end)\n          ) {\n            observer.next(\n              new SimpleFeature({\n                ...f1,\n                uniqueId: `${index}-${rowNum}`,\n                syntenyId: rowNum,\n                // note: strand would be -1 if the two features are on opposite strands,\n                // indicating inverted alignment\n                strand: f1.strand * f2.strand,\n                score,\n                mate: f2 as BareFeature,\n              }),\n            )\n          }\n        })\n      }\n\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the forseeable future and can be purged\n   * from caches, etc\n   */\n  freeResources(/* { region } */): void {}\n}\n","import { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nexport function isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split('\\n')\n      .filter(f => !!f || f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start,\n            end: +end,\n            score: +score,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  const buffer = (await file.readFile(opts)) as Buffer\n  return new TextDecoder('utf8', { fatal: true }).decode(\n    isGzip(buffer) ? await unzip(buffer) : buffer,\n  )\n}\n"],"names":["MCScanAnchorsAdapter","setupP","opts","this","setupPre","catch","e","undefined","assemblyNames","getConf","pm","pluginManager","bed1","openLocation","bed2","mcscan","Promise","all","map","r","readFile","bed1text","bed2text","mcscantext","bed1Map","parseBed","bed2Map","feats","split","filter","f","line","index","name1","name2","score","r1","get","r2","Error","region","ObservableCreate","observer","setup","indexOf","assemblyName","forEach","rowNum","f1","f2","refName","doesIntersect2","start","end","next","SimpleFeature","uniqueId","syntenyId","strand","mate","complete","BaseFeatureDataAdapter","capabilities","isGzip","buf","text","Map","startsWith","name","file","buffer","TextDecoder","fatal","unzip","decode"],"sourceRoot":""}